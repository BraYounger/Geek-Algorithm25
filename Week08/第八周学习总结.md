# 第八周学习总结

## 1.字典树(Trie)

### 1.1.数据结构

树形结构，根节点以下的每个节点存储单一字符。（节点上还可以存储额外的信息来支持实际应用需求，如被查询的频次）

### 1.2.核心思想

- 空间换时间
- 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的

### 1.3.基本性质

- 节点本身不存完整单词
- 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串
- 每个节点的所有子节点路径代表的字符都不相同



## 2.并查集

### 2.1.代码模板

```java
class UnionFind {
    private int count = 0;
    private int[] parent;

    public UnionFind(int n) {
        count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public int find(int p) {
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];
            p = parent[p];
        }
        return p;
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ;
        count--;
    }
}
```



## 3.AVL树

### 3.1.定义

平衡二叉搜索树

### 3.2.如何保证平衡？

- 平衡因子：某个节点左右字数的高度差，需要保证在{-1,0,1}内
- 节点插入/删除时如果不满足平衡条件则需要通过旋转操作来调整树结构：
  - 左左子树 - 右旋
  - 右右子树 - 左旋
  - 左右子树 - 左右旋（相当于先转化成左左子树再进行右旋）
  - 右左子树 - 右左旋（相当于先转化成右右子树再进行左旋）

### 3.3.不足

- 节点需要存储额外信息
- 调整次数频繁



## 4.红黑树

### 4.1.定义

近似平衡的二叉搜索树，能够确保每个节点的左右子树高度差小于两倍

### 4.2.性质

- 每个节点要么是红色，要么是黑色
- 根节点是黑色
- 每个叶子节点（空节点）是黑色
- 不存在相连的两个红色节点
- 每个节点到其下每个叶子节点的路径中均包含相同数目的黑色节点

### 4.3.与AVL树对比

- 相比于AVL树，红黑树的查询速度要慢，因为AVL树的平衡因子更小
- 相比于AVL树，红黑树的新增/编辑操作速度更快，因为红黑树只需要保证近似平衡，旋转操作会更简单
- 相比于AVL树，红黑树所需要占用的空间更小，因为AVL树需要在每个节点记录高度和平衡因子，而红黑树只需要在每个节点记录节点的颜色（例如，int型字段，1表示红，0表示黑）
- 红黑树一般被用于写操作较多或读写频次差不多的场景（高级语言库），AVL树一般被用于读操作较多的场景（数据库中）